<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ°´æœå¿è€… - ä¼˜åŒ–ç‰ˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            cursor: crosshair;
            user-select: none;
        }

        #gameCanvas {
            display: block;
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 100%);
            border: 3px solid #333;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
        }

        #gameInfo {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.7);
            z-index: 100;
        }

        #score {
            margin-bottom: 15px;
            color: #FFD700;
        }

        #lives {
            color: #ff6b6b;
        }

        #combo {
            color: #00ff00;
            font-size: 20px;
            margin-top: 10px;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            display: none;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
        }

        #gameOver h2 {
            margin-bottom: 25px;
            font-size: 36px;
            color: #FFD700;
        }

        #restartBtn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 20px;
            border-radius: 25px;
            cursor: pointer;
            margin-top: 25px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }

        #restartBtn:hover {
            background: linear-gradient(45deg, #45a049, #3d8b40);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        #pauseBtn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.2);
            color: white;
            border: 2px solid white;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 16px;
            backdrop-filter: blur(10px);
        }

        .fruit {
            position: absolute;
            border-radius: 50%;
            transition: all 0.1s ease;
        }

        .slice-effect {
            position: absolute;
            width: 6px;
            background: linear-gradient(90deg, transparent, #fff, transparent);
            pointer-events: none;
            animation: slice 0.4s ease-out forwards;
            box-shadow: 0 0 10px rgba(255,255,255,0.8);
        }

        @keyframes slice {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(2);
            }
        }

        .score-popup {
            position: absolute;
            color: #FFD700;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            animation: scorePopup 1s ease-out forwards;
        }

        @keyframes scorePopup {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-50px) scale(1.5);
            }
        }

        .combo-text {
            position: absolute;
            color: #ff4500;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            animation: comboAnimation 1.2s ease-out forwards;
        }

        @keyframes comboAnimation {
            0% {
                opacity: 1;
                transform: scale(0.5) rotate(-10deg);
            }
            50% {
                transform: scale(1.2) rotate(5deg);
            }
            100% {
                opacity: 0;
                transform: scale(1) rotate(0deg) translateY(-30px);
            }
        }

        @keyframes fall {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(120px) rotate(360deg);
                opacity: 0;
            }
        }

        .bomb {
            background: radial-gradient(circle at 30% 30%, #333, #000);
            border: 3px solid #ff0000;
        }

        .special-fruit {
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
            animation: glow 1s ease-in-out infinite alternate;
        }

        @keyframes glow {
            0% {
                box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
            }
            100% {
                box-shadow: 0 0 25px rgba(255, 215, 0, 1);
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="gameInfo">
        <div id="score">å¾—åˆ†: 0</div>
        <div id="lives">ç”Ÿå‘½: 3</div>
        <div id="combo" style="display: none;">è¿å‡»: 0</div>
    </div>

    <button id="pauseBtn" onclick="game.togglePause()">æš‚åœ</button>

    <div id="startHint" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 28px; text-align: center; pointer-events: none; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">
        ğŸ¥· æŒ‰ä½é¼ æ ‡å·¦é”®å¹¶æ‹–æ‹½æ¥åˆ‡å‰²æ°´æœï¼<br>
        <span style="font-size: 20px; color: #FFD700;">é¿å¼€ç‚¸å¼¹ï¼Œè¿ç»­åˆ‡å‰²è·å¾—æ›´é«˜åˆ†æ•°ï¼</span>
    </div>

    <div id="gameOver">
        <h2>ğŸ¯ æ¸¸æˆç»“æŸ</h2>
        <p>æœ€ç»ˆå¾—åˆ†: <span id="finalScore">0</span></p>
        <p>æœ€é«˜è¿å‡»: <span id="maxCombo">0</span></p>
        <button id="restartBtn">ğŸ”„ é‡æ–°å¼€å§‹</button>
    </div>

    <script>
        class FruitNinja {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.score = 0;
                this.lives = 3;
                this.combo = 0;
                this.maxCombo = 0;
                this.fruits = [];
                this.particles = [];
                this.scorePopups = [];
                this.isMouseDown = false;
                this.mouseTrail = [];
                this.gameRunning = true;
                this.isPaused = false;
                this.lastComboTime = 0;
                this.fruitTypes = ['apple', 'orange', 'banana', 'watermelon', 'grape'];
                this.specialFruitChance = 0.1; // 10% ç‰¹æ®Šæ°´æœæ¦‚ç‡
                this.bombChance = 0.05; // 5% ç‚¸å¼¹æ¦‚ç‡
                this.difficulty = 1;
                this.lastSpawnTime = 0;
                
                // æ€§èƒ½ä¼˜åŒ–ï¼šä½¿ç”¨ç¦»å±ç”»å¸ƒ
                this.offscreenCanvas = document.createElement('canvas');
                this.offscreenCtx = this.offscreenCanvas.getContext('2d');
                
                this.setupCanvas();
                this.setupEventListeners();
                this.updateUI();
                this.spawnFruit();
                this.gameLoop();
            }

            setupCanvas() {
                // åœ¨iframeä¸­ä½¿ç”¨çˆ¶å®¹å™¨çš„å°ºå¯¸ï¼Œå¦åˆ™ä½¿ç”¨windowå°ºå¯¸
                const containerWidth = this.canvas.parentElement.clientWidth || window.innerWidth;
                const containerHeight = this.canvas.parentElement.clientHeight || window.innerHeight;
                
                this.canvas.width = containerWidth;
                this.canvas.height = containerHeight;
                this.offscreenCanvas.width = this.canvas.width;
                this.offscreenCanvas.height = this.canvas.height;
                
                // è®¾ç½®ç”»å¸ƒèƒŒæ™¯è‰²ï¼Œç¡®ä¿ç”»å¸ƒå¯è§
                this.ctx.fillStyle = '#87CEEB';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                window.addEventListener('resize', () => {
                    const newWidth = this.canvas.parentElement.clientWidth || window.innerWidth;
                    const newHeight = this.canvas.parentElement.clientHeight || window.innerHeight;
                    this.canvas.width = newWidth;
                    this.canvas.height = newHeight;
                    this.offscreenCanvas.width = this.canvas.width;
                    this.offscreenCanvas.height = this.canvas.height;
                });
            }

            togglePause() {
                this.isPaused = !this.isPaused;
                const pauseBtn = document.getElementById('pauseBtn');
                pauseBtn.textContent = this.isPaused ? 'ç»§ç»­' : 'æš‚åœ';
            }

            setupEventListeners() {
                this.canvas.addEventListener('mousedown', (e) => {
                    if (this.isPaused) return;
                    this.isMouseDown = true;
                    this.mouseTrail = [{x: e.clientX, y: e.clientY}];
                    
                    // éšè—å¼€å§‹æç¤º
                    const startHint = document.getElementById('startHint');
                    if (startHint.style.display !== 'none') {
                        startHint.style.display = 'none';
                    }
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.isMouseDown && !this.isPaused) {
                        this.mouseTrail.push({x: e.clientX, y: e.clientY});
                        if (this.mouseTrail.length > 15) {
                            this.mouseTrail.shift();
                        }
                        this.checkFruitSlice();
                    }
                });

                this.canvas.addEventListener('mouseup', () => {
                    this.isMouseDown = false;
                    this.mouseTrail = [];
                    // é‡ç½®è¿å‡»è®¡æ—¶å™¨
                    if (this.combo > 0) {
                        this.lastComboTime = Date.now();
                    }
                });

                // æ·»åŠ è§¦æ‘¸æ”¯æŒ
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousedown', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    this.canvas.dispatchEvent(mouseEvent);
                });

                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    this.canvas.dispatchEvent(mouseEvent);
                });

                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    const mouseEvent = new MouseEvent('mouseup', {});
                    this.canvas.dispatchEvent(mouseEvent);
                });

                document.getElementById('restartBtn').addEventListener('click', () => {
                    this.restart();
                });

                // é”®ç›˜æ”¯æŒ
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') {
                        e.preventDefault();
                        this.togglePause();
                    }
                });
            }

            spawnFruit() {
                if (!this.gameRunning) return;

                const now = Date.now();
                const spawnDelay = Math.max(500, 1500 - this.difficulty * 100);
                
                if (now - this.lastSpawnTime < spawnDelay) {
                    setTimeout(() => this.spawnFruit(), 100);
                    return;
                }
                
                this.lastSpawnTime = now;

                const isBomb = Math.random() < this.bombChance;
                const isSpecial = !isBomb && Math.random() < this.specialFruitChance;
                
                const fruit = {
                    x: Math.random() * (this.canvas.width - 200) + 100,
                    y: this.canvas.height + 50,
                    vx: (Math.random() - 0.5) * (6 + this.difficulty),
                    vy: -Math.random() * (12 + this.difficulty * 2) - 10,
                    radius: isBomb ? 35 : (Math.random() * 25 + 30),
                    type: isBomb ? 'bomb' : this.fruitTypes[Math.floor(Math.random() * this.fruitTypes.length)],
                    sliced: false,
                    rotation: 0,
                    rotationSpeed: (Math.random() - 0.5) * 0.2,
                    isBomb: isBomb,
                    isSpecial: isSpecial,
                    sparkles: isSpecial ? [] : null
                };

                // ä¸ºç‰¹æ®Šæ°´æœæ·»åŠ é—ªçƒæ•ˆæœ
                if (isSpecial) {
                    for (let i = 0; i < 5; i++) {
                        fruit.sparkles.push({
                            x: Math.random() * 20 - 10,
                            y: Math.random() * 20 - 10,
                            life: Math.random() * 30 + 30
                        });
                    }
                }

                this.fruits.push(fruit);
                
                // å¢åŠ éš¾åº¦
                if (this.score > 0 && this.score % 100 === 0) {
                    this.difficulty = Math.min(5, Math.floor(this.score / 100) + 1);
                }
                
                // ç»§ç»­ç”Ÿæˆä¸‹ä¸€ä¸ªæ°´æœ
                setTimeout(() => this.spawnFruit(), Math.random() * spawnDelay + 200);
            }

            updateFruits() {
                // æ£€æŸ¥è¿å‡»è¶…æ—¶
                if (this.combo > 0 && Date.now() - this.lastComboTime > 1000) {
                    this.combo = 0;
                    this.updateUI();
                }

                for (let i = this.fruits.length - 1; i >= 0; i--) {
                    const fruit = this.fruits[i];
                    
                    if (!fruit.sliced) {
                        fruit.x += fruit.vx;
                        fruit.y += fruit.vy;
                        fruit.vy += 0.3; // gravity
                        fruit.rotation += fruit.rotationSpeed;
                        
                        // æ›´æ–°ç‰¹æ®Šæ°´æœé—ªçƒæ•ˆæœ
                        if (fruit.isSpecial && fruit.sparkles) {
                            for (let j = fruit.sparkles.length - 1; j >= 0; j--) {
                                const sparkle = fruit.sparkles[j];
                                sparkle.life--;
                                if (sparkle.life <= 0) {
                                    fruit.sparkles.splice(j, 1);
                                    // æ·»åŠ æ–°çš„é—ªçƒç‚¹
                                    fruit.sparkles.push({
                                        x: Math.random() * 20 - 10,
                                        y: Math.random() * 20 - 10,
                                        life: Math.random() * 30 + 30
                                    });
                                }
                            }
                        }
                        
                        // æ£€æŸ¥æ˜¯å¦æ‰å‡ºå±å¹•
                        if (fruit.y > this.canvas.height + 100) {
                            if (!fruit.sliced && !fruit.isBomb) {
                                this.lives--;
                                this.combo = 0; // é‡ç½®è¿å‡»
                                this.updateUI();
                                if (this.lives <= 0) {
                                    this.gameOver();
                                }
                            }
                            this.fruits.splice(i, 1);
                        }
                    } else {
                        // è¢«åˆ‡å¼€çš„æ°´æœç¢ç‰‡
                        fruit.x += fruit.vx;
                        fruit.y += fruit.vy;
                        fruit.vy += 0.5;
                        fruit.rotation += fruit.rotationSpeed;
                        fruit.radius *= 0.98;
                        
                        if (fruit.radius < 5) {
                            this.fruits.splice(i, 1);
                        }
                    }
                }
            }

            checkFruitSlice() {
                if (this.mouseTrail.length < 2) return;

                let slicedCount = 0;
                for (let fruit of this.fruits) {
                    if (fruit.sliced) continue;

                    for (let i = 0; i < this.mouseTrail.length - 1; i++) {
                        const p1 = this.mouseTrail[i];
                        const p2 = this.mouseTrail[i + 1];
                        
                        if (this.lineCircleIntersection(p1, p2, fruit)) {
                            this.sliceFruit(fruit);
                            slicedCount++;
                            break;
                        }
                    }
                }

                // å¦‚æœåœ¨ä¸€æ¬¡æ»‘åŠ¨ä¸­åˆ‡åˆ°å¤šä¸ªæ°´æœï¼Œå¢åŠ è¿å‡»
                if (slicedCount > 1) {
                    this.combo += slicedCount - 1;
                    this.showComboText(slicedCount);
                }
            }

            lineCircleIntersection(p1, p2, fruit) {
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const fx = p1.x - fruit.x;
                const fy = p1.y - fruit.y;

                const a = dx * dx + dy * dy;
                const b = 2 * (fx * dx + fy * dy);
                const c = (fx * fx + fy * fy) - fruit.radius * fruit.radius;

                const discriminant = b * b - 4 * a * c;
                
                if (discriminant < 0) return false;
                
                const discriminantSqrt = Math.sqrt(discriminant);
                const t1 = (-b - discriminantSqrt) / (2 * a);
                const t2 = (-b + discriminantSqrt) / (2 * a);

                return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1);
            }

            sliceFruit(fruit) {
                fruit.sliced = true;
                
                // å¤„ç†ç‚¸å¼¹
                if (fruit.isBomb) {
                    this.lives--;
                    this.combo = 0;
                    this.createExplosion(fruit.x, fruit.y);
                    this.updateUI();
                    if (this.lives <= 0) {
                        this.gameOver();
                    }
                    return;
                }
                
                // è®¡ç®—å¾—åˆ†
                let points = 10;
                if (fruit.isSpecial) {
                    points = 50;
                }
                
                // è¿å‡»åŠ åˆ†
                this.combo++;
                if (this.combo > 1) {
                    points += this.combo * 5;
                }
                
                if (this.combo > this.maxCombo) {
                    this.maxCombo = this.combo;
                }
                
                this.score += points;
                this.lastComboTime = Date.now();
                this.updateUI();
                
                // æ˜¾ç¤ºå¾—åˆ†å¼¹å‡º
                this.showScorePopup(fruit.x, fruit.y, points);
                
                // åˆ›å»ºåˆ‡å‰²æ•ˆæœ
                this.createSliceEffect(fruit.x, fruit.y);
                
                // åˆ›å»ºæ°´æœç¢ç‰‡
                const pieceCount = fruit.isSpecial ? 10 : 6;
                for (let i = 0; i < pieceCount; i++) {
                    const piece = {
                        x: fruit.x + (Math.random() - 0.5) * 30,
                        y: fruit.y + (Math.random() - 0.5) * 30,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10 - 3,
                        radius: fruit.radius * (0.2 + Math.random() * 0.2),
                        type: fruit.type,
                        sliced: true,
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.4,
                        isBomb: false,
                        isSpecial: false
                    };
                    this.fruits.push(piece);
                }
            }

            createSliceEffect(x, y) {
                const effect = {
                    x: x,
                    y: y,
                    life: 40,
                    maxLife: 40,
                    type: 'slice'
                };
                this.particles.push(effect);
            }

            createExplosion(x, y) {
                // åˆ›å»ºçˆ†ç‚¸ç²’å­
                for (let i = 0; i < 15; i++) {
                    const particle = {
                        x: x + (Math.random() - 0.5) * 20,
                        y: y + (Math.random() - 0.5) * 20,
                        vx: (Math.random() - 0.5) * 15,
                        vy: (Math.random() - 0.5) * 15,
                        life: 60,
                        maxLife: 60,
                        type: 'explosion'
                    };
                    this.particles.push(particle);
                }
            }

            showScorePopup(x, y, points) {
                const popup = {
                    x: x,
                    y: y,
                    points: points,
                    life: 60,
                    maxLife: 60
                };
                this.scorePopups.push(popup);
            }

            showComboText(count) {
                if (count > 1) {
                    const comboDiv = document.createElement('div');
                    comboDiv.className = 'combo-text';
                    comboDiv.textContent = `${count}x è¿å‡»!`;
                    comboDiv.style.left = (this.canvas.width / 2 - 50) + 'px';
                    comboDiv.style.top = (this.canvas.height / 2 - 100) + 'px';
                    document.body.appendChild(comboDiv);
                    
                    setTimeout(() => {
                        document.body.removeChild(comboDiv);
                    }, 1200);
                }
            }

            updateParticles() {
                // æ›´æ–°ç²’å­
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    particle.life--;
                    
                    if (particle.type === 'explosion') {
                        particle.x += particle.vx;
                        particle.y += particle.vy;
                        particle.vx *= 0.98;
                        particle.vy *= 0.98;
                    }
                    
                    if (particle.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
                
                // æ›´æ–°å¾—åˆ†å¼¹å‡º
                for (let i = this.scorePopups.length - 1; i >= 0; i--) {
                    const popup = this.scorePopups[i];
                    popup.life--;
                    popup.y -= 1;
                    
                    if (popup.life <= 0) {
                        this.scorePopups.splice(i, 1);
                    }
                }
            }

            draw() {
                // ä½¿ç”¨ç¦»å±ç”»å¸ƒæé«˜æ€§èƒ½
                const ctx = this.offscreenCtx;
                
                // ç»˜åˆ¶å¤©ç©ºæ¸å˜èƒŒæ™¯
                const gradient = ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(0.7, '#98FB98');
                gradient.addColorStop(1, '#90EE90');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ç»˜åˆ¶äº‘æœµèƒŒæ™¯
                this.drawClouds(ctx);
                
                // ç»˜åˆ¶é¼ æ ‡è½¨è¿¹ï¼ˆæ›´ç‚«é…·çš„æ•ˆæœï¼‰
                if (this.mouseTrail.length > 1) {
                    for (let i = 0; i < this.mouseTrail.length - 1; i++) {
                        const alpha = (i / this.mouseTrail.length) * 0.8;
                        const width = 5 - (i / this.mouseTrail.length) * 3;
                        
                        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                        ctx.lineWidth = width;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(this.mouseTrail[i].x, this.mouseTrail[i].y);
                        ctx.lineTo(this.mouseTrail[i + 1].x, this.mouseTrail[i + 1].y);
                        ctx.stroke();
                        
                        // æ·»åŠ å‘å…‰æ•ˆæœ
                        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.3})`;
                        ctx.lineWidth = width + 4;
                        ctx.stroke();
                    }
                }

                // ç»˜åˆ¶æ°´æœ
                for (let fruit of this.fruits) {
                    this.drawFruit(fruit, ctx);
                }

                // ç»˜åˆ¶ç²’å­æ•ˆæœ
                for (let particle of this.particles) {
                    this.drawParticle(particle, ctx);
                }
                
                // ç»˜åˆ¶å¾—åˆ†å¼¹å‡º
                for (let popup of this.scorePopups) {
                    this.drawScorePopup(popup, ctx);
                }
                
                // å°†ç¦»å±ç”»å¸ƒå¤åˆ¶åˆ°ä¸»ç”»å¸ƒ
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.drawImage(this.offscreenCanvas, 0, 0);
            }

            drawClouds(ctx) {
                // ç»˜åˆ¶ç®€å•çš„äº‘æœµæ•ˆæœ
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                const cloudCount = 5;
                for (let i = 0; i < cloudCount; i++) {
                    const x = (this.canvas.width / cloudCount) * i + Math.sin(Date.now() * 0.0005 + i) * 50;
                    const y = 50 + Math.cos(Date.now() * 0.0003 + i) * 30;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 30, 0, Math.PI * 2);
                    ctx.arc(x + 25, y, 35, 0, Math.PI * 2);
                    ctx.arc(x + 50, y, 30, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            drawFruit(fruit, ctx) {
                ctx.save();
                ctx.translate(fruit.x, fruit.y);
                ctx.rotate(fruit.rotation);
                
                if (fruit.isBomb) {
                    // ç»˜åˆ¶ç‚¸å¼¹
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, fruit.radius);
                    gradient.addColorStop(0, '#555');
                    gradient.addColorStop(1, '#000');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, fruit.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ç‚¸å¼¹è¾¹æ¡†
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    // ç‚¸å¼¹å¼•çº¿
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(0, -fruit.radius);
                    ctx.lineTo(0, -fruit.radius - 15);
                    ctx.stroke();
                    
                    // ç«èŠ±æ•ˆæœ
                    ctx.fillStyle = '#ff4500';
                    ctx.beginPath();
                    ctx.arc(0, -fruit.radius - 15, 3, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // æ ¹æ®æ°´æœç±»å‹è®¾ç½®é¢œè‰²
                    const colors = {
                        apple: '#ff6b6b',
                        orange: '#ffa500',
                        banana: '#ffeb3b',
                        watermelon: '#ff1744',
                        grape: '#9c27b0'
                    };
                    
                    // ç‰¹æ®Šæ°´æœå‘å…‰æ•ˆæœ
                    if (fruit.isSpecial && !fruit.sliced) {
                        const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, fruit.radius + 10);
                        glowGradient.addColorStop(0, 'rgba(255, 215, 0, 0)');
                        glowGradient.addColorStop(1, 'rgba(255, 215, 0, 0.6)');
                        ctx.fillStyle = glowGradient;
                        ctx.beginPath();
                        ctx.arc(0, 0, fruit.radius + 10, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // ç»˜åˆ¶æ°´æœä¸»ä½“
                    const gradient = ctx.createRadialGradient(-fruit.radius * 0.3, -fruit.radius * 0.3, 0, 0, 0, fruit.radius);
                    gradient.addColorStop(0, colors[fruit.type]);
                    gradient.addColorStop(1, this.darkenColor(colors[fruit.type], 0.3));
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, fruit.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // æ·»åŠ è¾¹æ¡†
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // æ·»åŠ é«˜å…‰æ•ˆæœ
                    if (!fruit.sliced) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                        ctx.beginPath();
                        ctx.arc(-fruit.radius * 0.3, -fruit.radius * 0.3, fruit.radius * 0.3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // ç»˜åˆ¶ç‰¹æ®Šæ°´æœçš„é—ªçƒç‚¹
                    if (fruit.isSpecial && fruit.sparkles) {
                        for (let sparkle of fruit.sparkles) {
                            const alpha = sparkle.life / 60;
                            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                            ctx.beginPath();
                            ctx.arc(sparkle.x, sparkle.y, 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    
                    // å¦‚æœè¢«åˆ‡å¼€ï¼Œæ·»åŠ å†…éƒ¨æ•ˆæœ
                    if (fruit.sliced) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.beginPath();
                        ctx.arc(0, 0, fruit.radius * 0.7, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                ctx.restore();
            }

            darkenColor(color, amount) {
                // ç®€å•çš„é¢œè‰²å˜æš—å‡½æ•°
                const colorMap = {
                    '#ff6b6b': '#cc5555',
                    '#ffa500': '#cc8400',
                    '#ffeb3b': '#ccbc2f',
                    '#ff1744': '#cc1236',
                    '#9c27b0': '#7d1f8d'
                };
                return colorMap[color] || color;
            }

            drawParticle(particle, ctx) {
                const alpha = particle.life / particle.maxLife;
                
                if (particle.type === 'slice') {
                    ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, (1 - alpha) * 25, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (particle.type === 'explosion') {
                    ctx.fillStyle = `rgba(255, ${100 + alpha * 155}, 0, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, 4 - alpha * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            drawScorePopup(popup, ctx) {
                const alpha = popup.life / popup.maxLife;
                const scale = 1 + (1 - alpha) * 0.5;
                
                ctx.save();
                ctx.translate(popup.x, popup.y);
                ctx.scale(scale, scale);
                ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`;
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`+${popup.points}`, 0, 0);
                
                // æ·»åŠ é˜´å½±æ•ˆæœ
                ctx.fillStyle = `rgba(0, 0, 0, ${alpha * 0.5})`;
                ctx.fillText(`+${popup.points}`, 2, 2);
                ctx.restore();
            }

            updateUI() {
                document.getElementById('score').textContent = `å¾—åˆ†: ${this.score}`;
                document.getElementById('lives').textContent = `ç”Ÿå‘½: ${this.lives}`;
                
                const comboDiv = document.getElementById('combo');
                if (this.combo > 1) {
                    comboDiv.style.display = 'block';
                    comboDiv.textContent = `è¿å‡»: ${this.combo}x`;
                } else {
                    comboDiv.style.display = 'none';
                }
            }

            gameOver() {
                this.gameRunning = false;
                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('maxCombo').textContent = this.maxCombo;
                document.getElementById('gameOver').style.display = 'block';
            }

            restart() {
                this.score = 0;
                this.lives = 3;
                this.combo = 0;
                this.maxCombo = 0;
                this.fruits = [];
                this.particles = [];
                this.scorePopups = [];
                this.mouseTrail = [];
                this.gameRunning = true;
                this.isPaused = false;
                this.difficulty = 1;
                this.lastSpawnTime = 0;
                this.lastComboTime = 0;
                
                document.getElementById('gameOver').style.display = 'none';
                document.getElementById('pauseBtn').textContent = 'æš‚åœ';
                this.updateUI();
                this.spawnFruit();
            }

            gameLoop() {
                if (this.gameRunning && !this.isPaused) {
                    this.updateFruits();
                    this.updateParticles();
                }
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }
        }

        // å¯åŠ¨æ¸¸æˆ
        let game;
        window.addEventListener('load', () => {
            game = new FruitNinja();
        });
    </script>
</body>
</html>